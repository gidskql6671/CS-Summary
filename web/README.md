# Web
## HTTP

### HTTP의 역사
#### HTTP/1.0
현재의 HTTP의 기본적인 기능을 포함하게 된 버전이다. 

- HTTP Reqeust의 Start line에 버전 정보를 기입함.
- HTTP Response의 Start line에 상태 코드(Status Code)를 기입함.
- GET, POST와 같은 기본적인 메서드가 추가되었다.
- 헤더의 추가(user-agent, Content-Type 등)
    - 메타데이터의 전송을 허용하고, 프로토콜을 유연하고 확장가능하도록 만들었다.
    - 또한, 헤더의 도움으로 HTML 파일 이외의 다른 문서들을 전송할 수 있게 되었다. (Content-Type)
    
#### HTTP/1.1
이전 버전에서 발견된 프로토콜의 모호성들을 해결하고, 성능 최적화에 중점을 둔 버전이다.

- TLS 암호화 통신 (https)
- Keep-Alive 연결이 추가됨
    - 커넥션을 재사용할 수 있게 되었다.
- 파이프라이닝 기능이 추가됨
    - 첫번째 요청에 대한 응답이 완전히 전송되기 전에 두번째 요청 전송을 가능하도록 함.
- Response를 청크로 나누어 보낼 수 있게 됨.
- PUT, DELETE와 같은 추가적인 메서드가 추가되었다.
- XmlHttpRequest 추가
    - 서버와 비동기 통신이 가능해짐
    
#### HTTP/2.0
2009년 구글에 의해 발표된 SPDY 프로토콜에서부터 생겨난 버전이다. 

- HTTP 1.1 까지의 핵심기능을 유지하며 확장하였다.
- 하나의 Connection에서 여러 요청/응답을 병렬로 전달한다.(멀티플렉싱)
    - 여러개의 바이너리 인코딩된 프레임으로 구성된 Stream을 병렬적으로 보내준다.
    - 요청에 우선순위(가중치)를 지정할 수 있다.
- Header 필드를 압축할 수 있음
    - 프로토콜의 오버헤드를 최소화할 수 있다.
- Server Push를 지원한다.
    - 하나를 요청해도 서버에서 여러개를 보내주는 것
- HTTP를 독립된 프레임으로 세분화하여 전송할 수 있다.
- [HTTP/2 소개](https://developers.google.com/web/fundamentals/performance/http2) 해당 링크에 자세한 설명이 나와있다.

#### HTTP/3
UDP 기반의 **QUIC 프로토콜**을 사용하는 프로토콜이다. 속도가 느린 TCP 대신 UDP를 사용함으로써 빠르게 통신할 수 있다.
참고로 QUIC은 `Quick UDP Internet Connection`의 약자로 이름에서부터 빠른 속도를 지향하는 프로토콜임을 알 수 있다.

UDP를 사용함으로서 얻는 장점은 여럿 있겠지만, 연결을 설정하는데 발생하는 비용을 매우 줄일 수 있다는 장점이 가장 큰 장점일 것이다.
TCP는 이미 프로토콜 자체가 무거워서 커스터마이징하는 것이 힘들지만, UDP는 그냥 새하얀 도화지같은 상태이다.
그래서 UDP를 사용하여 구조자체를 바꿀려는 시도를 하는 것 같다.

위에서 언급한 것 말고도 다른 장점들을 간단히 정리해보면 다음과 같다.
- 연결을 설정할 때의 비용이 감소된다.
- 패킷 손실 감지에 걸리는 시간이 단축된다.
- 멀티플렉싱을 지원한다.
    - HTTP/2에서도 마찬가지로 지원하는 기능이다.
- 클라이언트의 IP 주소가 바뀌어도 연결이 유지된다.
    - TCP는 IP 주소와 포트로 연결을 식별하기에, IP가 바뀌면 연결도 끊어진다.
    - 요새는 모바일로 인터넷을 많이 써서, IP가 바뀌는 일이 잦다.
    - QUIC는 Connection ID라는 다른 개념을 사용하여 서버와 연결하기에, IP 주수고 바뀌어도 연결이 유지된다.


### HTTP Status Code
- 1xx (정보): 요청을 받았으며 프로세스를 계속한다
- 2xx (성공): 요청을 성공적으로 받았으며 인식했고 수용하였다
- 3xx (리다이렉션): 요청 완료를 위해 추가 작업 조치가 필요하다
- 4xx (클라이언트 오류): 요청의 문법이 잘못되었거나 요청을 처리할 수 없다
- 5xx (서버 오류): 서버가 명백히 유효한 요청에 대해 충족을 실패했다

가장 앞자리는 위처럼 분류되어 있다. 상세한 분류는 필요할 때 그때그때 보는게 맞다고 생각한다.

### HTTPS
HTTPS란 SSL/TLS가 추가된 HTTP 프로토콜로 볼 수 있다. 기존의 HTTP는 소켓 통신을 통해 평문으로 데이터를 주고받았지만, HTTPS는 SSL 혹은 TLS를 통해 세션 데이터를 암호화한다.

여기서 TLS는 TCP/IP 4계층의 응용 계층과 전송 계층 사이에서 동작하는 별개의 프로토콜이다. 다만, 응용 계층은 TLS를 전송 계층으로 간주하고, 반대로 전송 계층은 TLS를 응용 계층으로 간주한다. 그렇기 때문에 두 계층의 별도의 수정 없이도 TLS가 동작할 수 있다.

#### HTTPS의 암호화 방식
HTTPS에서는 대칭키 암호화 방식과 공개키 암호화 방식을 혼합한 암호 시스템을 사용한다. 대칭키를 공개키 암호화 방식으로 교환한 다음, 이후의 통신은 대칭키 암호화 방식을 사용한다.

공개키 암호화 방식만 사용하지 않고 대칭키 방식을 섞는 이유는 암호화 및 복호화의 비용 문제이다. 공개키 및 비밀키는 키의 길이가 길기 때문에, 암호화 및 복호화 비용이 대칭키보다 크다. 그래서 초기에 공개키 암호화를 이용해 대칭키를 주고받고, 이후로는 대칭키 암호화 방식을 사용하는 것이다.

해당 과정은 우선 서버가 CA로부터 인증서를 발급받는 것부터 시작된다.
1. 서버는 인증기관(CA)에 자신의 정보와 공개키를 제공한다.
2. 인증 기관은 인증 기관의 개인키로 서버가 제공한 정보를 암호화한 인증서를 만들어 서버에게 준다.
    - 이 인증서는 인증 기관의 개인키로 암호화되었기에, 인증 기관의 공개키로 복호화가 가능하다.
    - 공개키는 퍼블릭하게 공개되어있기에, 이 암호화는 데이터 보호의 목적보다는 신원 보장을 위한 암호화이다.

이후, 클라이언트가 서버에 접속하는 상황의 암호화를 설명하겠다.
1. 클라이언트가 사이트에 접속하면, 서버는 자신의 인증서를 보내준다.
    - 해당 인증서는 인증 기관의 개인키로 암호화돼있는 상태이다.
2. 클라이언트는 인증 기관의 공개키로 해당 인증서를 복호화하여 검증한다.
    - 이 복호화가 성공한다면, 이 인증서가 해당 서버로부터 온 응답임을 확실할 수 있게 된다.
    - 이 인증서에는 사이트의 정보와 서버의 공개키가 담겨있다.
3. 임의의 대칭키를 생성하고, 서버의 공개키로 대칭키를 암호화해서 사이트에 보낸다.
4. 서버는 자신의 개인키로 암호문을 복호화하여 대칭키를 얻게 되고, 이후로는 대칭키로 데이터를 주고받는다.


## URL

### URL vs URI vs URN

### URL Encoding (Percent Encoding)

## 웹 브라우저

### 브라우저 기본 구조

### 브라우저 동작 방식

### 렌더링 엔진

### DOM Tree

### CSSOM Tree

### Rendering Tree